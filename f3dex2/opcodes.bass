//===F3DEX2 Macros for Bass==========================================
// "Port" the standard F3DEX2 macros into bass
// in order to write and assemble display lists
//
// File is organized by byte op-codes, but
// macros are named and match the standard
// F3DEX2 library.
//===================================================================

//===00 G_NOOP===================================
macro gsDPNoOp() {
  dw  0x00000000
  dw  0x00000000
}
macro gsDPNoOpTag(tag) {
  dw  0x00000000
  dw  {tag} & 0xFFFFFFFF
}

//===01 G_VTX====================================
macro gsSPVertex(vaddr, numv, vbidx) {
  variable word1(0x010000000)
  if {numv} {
    word0 = word0 | ({numv} << 5)
  }
  if {vbidx} {
    word0 = word0 | ((({vbidx + numv}) & 0x7F) << 1)
  }

  dw word0
  dw {vaddr}
}

//===02 G_MODIFYVTX==============================
macro gsSPModifyVertex(vbidx, where, val) {
  // where is an enumerated flag value
  variable word0(0x02000000)

  word0 = word0 | (where << 16) | (vbidx << 1)

  dw word0
  dw ({val} & 0xFFFFFFFF)
}

//===03 G_CULLDL=================================
macro gsSPCullDisplayList(vfirst, vlast) {
  variable word0(0x03000000)
  variable word1(0x00000000)

  word0 = word0 | (vfirst << 2)
  word1 = word1 | (vlast << 2)

  dw word0, word1
}

//===04 G_BRANCH_Z===============================
// DON'T USE UNLESS YOU CAN PROVIDE A PROPER ZVAL
macro gsSPBranchLessZraw(newdl, vbidx, zval) {
  constant word0(0xE1000000)
  variable word1({newdl} & 0xFFFFFFFF)
  variable word2(0x04000000)
  variable word3({zval} & 0xFFFFFFFF)

  word2 = word2 | (({vbidx} * 5) << 12 ) | ({vbidx} << 2)

  dw word0, word1, word2, word3
}

// put in macro to calculate proper z val!!!

//===05 G_TRI1===================================
macro gsSP1Triangle(variable ver0, variable ver1, variable ver2, flag) {
  variable word1(0x05000000)
  ver0 = ver0 << 1; ver1 = ver1 << 1; ver2 = ver2 << 1;

  if {flag} == 1 {
    word0 = word0 | (ver1 << 16) | (ver2 << 8) | ver0
  } else if {flag} == 2 {
    word0 = word0 | (ver2 << 16) | (ver0 << 8) | ver1
  } else {
    word0 = word0 | (ver0 << 16) | (ver1 << 8) | ver2
  }
  dw word0, 0x00000000
}

//===06 G_TRI2===================================
macro gsSP2Triangles(variable v00, variable v01, variable v02, flag0, variable v10, variable v11, variable v12, flag1) {
  variable word0(0x06000000)
  variable word1(0x00000000)

  v00 = v00 << 1; v01 = v01 << 1; v02 = v02 << 1;
  v10 = v10 << 1; v11 = v11 << 1; v12 = v12 << 1;

  if {flag0} == 1 {
    word0 = word0 | (v01 << 16) | (v02 << 8) | v00
  } else if {flag0} == 2 {
    word0 = word0 | (v02 << 16) | (v00 << 8) | v01
  } else {
    word0 = word0 | (v00 << 16) | (v01 << 8) | v02
  }

  if {flag1} == 1 {
    word1 = word1 | (v11 << 16) | (v12 << 8) | v10
  } else if {flag0} == 2 {
    word1 = word1 | (v12 << 16) | (v10 << 8) | v11
  } else {
    word1 = word1 | (v10 << 16) | (v11 << 8) | v12
  }

  dw word0, word1
}

//===06 G_QUAD===================================
macro gsSPQuadrangle(variable v0, variable v1, variable v2, variable v3, flag) {
  variable word0(0x07000000)
  variable word1(0x00000000)

  if {flag} == 1 {
    word0 = word0 | (v1 << 16) | (v2 << 8) | v3
    word1 = word1 | (v1 << 16) | (v3 << 8) | v0
  } else if {flag} == 2 {
    word0 = word0 | (v2 << 16) | (v3 << 8) | v0
    word1 = word1 | (v2 << 16) | (v0 << 8) | v1
  } else if {flag} == 3 {
    word0 = word0 | (v3 << 16) | (v0 << 8) | v1
    word1 = word1 | (v3 << 16) | (v1 << 8) | v2
  } else {
    word0 = word0 | (v0 << 16) | (v1 << 8) | v2
    word1 = word1 | (v0 << 16) | (v2 << 8) | v3
  }

  dw word0, word1
}

//===0xD6 G_DMA_IO===============================
// gsSPDma_io(flag, dmem, dram, size)

// Does a DMA between DMEM/IMEM address dmem and DRAM address dram.
//size bytes are presumably transfered in the process.
// flag determines the type of transfer. Apparently:
//    flag == 0 — Read from DMEM/IMEM to DRAM
//    flag == 1 — Write DRAM to DMEM/IMEM
// The exact nature of this command is unclear, since none of this opcode's macros are documented,
// and the only available comment suggests this is a debugging tool only.
// Therefore, you should not expect to see this in production code.

//===0xD7 G_TEXTURE==============================
macro gsSPTexture(scaleS, scaleT, level, tile, on) {
  // 'on' is a boolean (0 | 1)
  variable word0(0xD7000000)
  variable word1(0x00000000)

  word0 = word0 | ( ({level} & 0x7) << 11 ) | ( ({title} & 0x7) < 8 ) | ({on} & 0x7)
  word1 = word1 | ( ({scaleS} & 0xFFFF) << 16 ) | ({scaleT} & 0xFFFF)

  dw word0, word1
}

//===0xD8 G_POPMTX===============================
macro gsSPPopMatrixN(which, num) {
  // 'which' is ignored lol
  variable word0(0xD8380002)
  variable word1( ({num} << 6) & 0xFFFFFFFF )

  dw word0, word1
}

//===0xD9 G_GEOMETRYMODE=========================
macro gsSPGeomentryMode(clearbits, setbits) {
  variable word0(0xD9000000)

  word0 = word0 | (~{clearbits} & 0xFFFFFF)

  dw word0, {setbits}
}

//===0xDA G_MTX==================================
macro gsSPMatrix(mtxaddr, params) {
  constant G_MTX_PUSH(0x01)
  variable word0(0xDA380000)

  word0 = word0 | ( ({params} & 0xFF) ^ G_MTX_PUSH )

  dw word0, {mtxaddr}
}

//===0xDB G_MOVEWORD=============================
macro gsMoveWd(index, offset, data) {
  variable word0(0xDB000000)

  word0 = word0 | ( ({index} & 0xFF) << 16) | ({offset} & 0xFFFF)

  dw word0, {data}
}

//===0xDC G_MOVEMEM==============================
// the function gsMoveMem is imaginary: all of the macros that use this opcode do so directly,
// as opposed to going through another function.
// Since no general macro exists for this opcode, gsMoveMem was invented for illustrative purposes.
macro gsMoveMem(size, index, offset, address) {
  variable word0(0xDC000000)

  word0 = word0 | ( (((({size} - 1) / 8) & 0x1F ) << 3 ) << 16 )
  word0 = word0 | ( ({offset} / 8) << 8 ) | ( {index} & 0xFF )

  dw word0, {address}
}

//===0xDD G_LOAD_UCODE===========================
macro gsSPLoadUcodeEx(tstart, dstart, dsize) {
  variable word0(0xE1000000)
  variable word2(0xDD000000)

  word2 = word2 | ( {dsize} & 0xFFFF )

  dw word0, {dstart}
  dw word2, {tstart}
}

//===0xDE G_DL===================================
macro gsSPDisplayList(dl){
  variable word0(0xDE000000)

  dw word0, {dl}
}
macro gsSPBranchList(dl){
  variable word0(0xDE010000)

  dw word0, {dl}
}

//===0xDF G_ENDDL================================
macro gsSPEndDisplayList() {
  dw 0xDF000000, 0x00000000
}

//===0xE0 G_SPNOOP===============================
macro gsSPNoOp() {
  dw 0xF0000000, 0x00000000
}

//===0xE1 G_RDPHALF_1============================
// NOTE: this macro emits both an E1 and an F1 code
// E1 code is used in other macros as well (make list?)
macro gsDPWord(wordhi, wordlo) {
  dw 0xE1000000, {wordhi}
  dw 0xF1000000, {wordlo}
}

//===0xE2 G_SETOTHERMODE_L=======================
//===0xE3 G_SETOTHERMODE_H=======================
macro gsSPSetOtherMode(half, shift, length, data) {
  variable word0(0)
  if {half} == 0xE2 {
    // for low
    word0 = word0 | (0xE2 << 24)
  } else if {half} == 0xE3 {
    // for high
    word0 = word0 | (0xE3 << 24)
  } else {
    error "{half} is not a proper magic number for gsSPSetOtherMode. Use 0xE2 (low) or 0xE3 (high)"
  }

  word0 = word0 | ((32 - ({shift} & 0xFF) - ({length} & 0xFF)) << 8)
  word0 = word0 | ({length} - 1 & 0xFF)

  dw word0, {data}
}
